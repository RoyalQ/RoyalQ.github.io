{"meta":{"title":"Rookie's think","subtitle":"程序猿上辈子都是折翼的天使","description":"你猜我写不写","author":"QXQ","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"日常记录","slug":"jilu","date":"2017-09-04T11:43:37.000Z","updated":"2017-09-04T12:17:16.000Z","comments":true,"path":"2017/09/04/jilu/","link":"","permalink":"http://yoursite.com/2017/09/04/jilu/","excerpt":"","text":"每日记录 日期 实践学习 理论学习 9.4 电脑转移拼装，社团app启动开发 9.5","categories":[{"name":"ios学习","slug":"ios学习","permalink":"http://yoursite.com/categories/ios学习/"}],"tags":[{"name":"学习路程","slug":"学习路程","permalink":"http://yoursite.com/tags/学习路程/"}]},{"title":"十大排序算法总结","slug":"十大算法","date":"2017-05-23T13:22:11.000Z","updated":"2017-05-25T13:10:19.000Z","comments":true,"path":"2017/05/23/十大算法/","link":"","permalink":"http://yoursite.com/2017/05/23/十大算法/","excerpt":"算法复杂度 算法复杂度分为时间复杂度和空间复杂度。 时间复杂度是度量算法执行的时间长短，简单的理解就是执行语句的条数。如果有循环和递归，则忽略简单语句，直接算循环和递归的语句的执行次数。","text":"算法复杂度 算法复杂度分为时间复杂度和空间复杂度。 时间复杂度是度量算法执行的时间长短，简单的理解就是执行语句的条数。如果有循环和递归，则忽略简单语句，直接算循环和递归的语句的执行次数。 空间复杂度：行完一个程序所需内存的大小。 常用时间复杂度所耗时间排序： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O((n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 排序算法冒泡排序：123456789void bubble_sort(int a[], int n)&#123;int i, j, temp; for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) //相邻元素两两对比 if(a[i] &gt; a[i + 1]) &#123;temp=a[i]; a[i]=a[i+1]; a[i+1]=temp;//元素交换 &#125;&#125; 冒泡排序是我们学C语言的第一个接触的排序算法，也是一种简单的算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，最佳时间复杂度正序O(n)，最差时间复杂度反序O(n^2)，平均时间复杂度O(n^2)，空间复杂度O(1),不占用额外内存，稳定，数据量小一般都用这个，但也不尽然，看具体情况。 动图展示啦啦 选择排序：选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 1234567891011121314151617181920212223void select_sort(int a[],int n)//n为数组a的元素个数&#123; //进行N-1轮选择 for(int i=0; i&lt;n-1; i++) &#123; int min_index = i; //找出第i小的数所在的位置 for(int j=i+1; j&lt;n; j++) &#123; if(a[j] &lt; a[min_index]) &#123; min_index = j; &#125; &#125; //将第i小的数，放在第i个位置；如果刚好，就不用交换 if( i != min_index) &#123; int temp = a[i]; a[i] = a[min_index]; a[min_index] = temp; &#125; &#125;&#125; 最佳最坏平均情况都是都为0(n^2),而空间复杂度同冒泡一样都为O(1)，但与冒泡不同的是，选择排序虽然表现最稳定，但因为无论什么数据进去都是O(n^2)的时间复杂度，所以，在算法层面并不稳定，适用于越小越好的数据规模。 动图展示啦啦 插入排序插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445void InsertSortArray() &#123; for(int i=1;i&lt;n;i++)//循环从第二个数组元素开始，因为arr[0]作为最初已排序部分 &#123; int temp=arr[i];//temp标记为未排序第一个元素 int j=i-1; while (j&gt;=0 &amp;&amp; arr[j]&gt;temp)/*将temp与已排序元素从小到大比较，寻找temp应插入的位置*/ &#123; arr[j+1]=arr[j]; j--; &#125; arr[j+1]=temp; &#125; &#125; ``` 最佳情况O（n），最差情况O（n²）与冒泡、选择相同，空间复杂度同冒泡选择，适用于排序小列表 ，若列表基本有序，则插入排序比冒泡、选择更有效率。动图展示啦啦 ![](/img/charu.gif)### 希尔排序简单插入排序的改进版，不同之处在于希尔排序优先比较距离较远的元素。具体算法描述：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1，按增量序列个数k，对序列进行k 趟排序，每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。``` bashvoid ShellSortArray() &#123; for(int incr=3;incr&lt;0;incr--)//增量递减，以增量3，2，1为例 &#123; for(int L=0;L&lt;(n-1)/incr;L++)//重复分成的每个子列表 &#123; for(int i=L+incr;i&lt;n;i+=incr)//对每个子列表应用插入排序 &#123; int temp=arr[i]; int j=i-incr; while(j&gt;=0&amp;&amp;arr[j]&gt;temp) &#123; arr[j+incr]=arr[j]; j-=incr; &#125; arr[j+incr]=temp; &#125; &#125; &#125; &#125; 这个适用于排序小列表，最佳与最坏情况都为O(nlog2 n),平均情况为O（nlogn），空间复杂度同上，该排序改进了插入排序，减少了比较的次数。是不稳定的排序，因为排序过程中元素可能会前后跳跃。 找不到动图，泪奔 归并排序归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。 12345678910111213141516171819202122232425void MergeSort(int low,int high) &#123; if(low&gt;=high) return;//每个子列表中剩下一个元素时停止 else int mid=(low+high)/2;/*将列表划分成相等的两个子列表,若有奇数个元素，则在左边子列表大于右侧子列表*/ MergeSort(low,mid);//子列表进一步划分 MergeSort(mid+1,high); int [] B=new int [high-low+1];//新建一个数组，用于存放归并的元素 for(int i=low,j=mid+1,k=low;i&lt;=mid &amp;&amp; j&lt;=high;k++)/*两个子列表进行排序归并，直到两个子列表中的一个结束*/ &#123; if (arr[i]&lt;=arr[j];) &#123; B[k]=arr[i]; I++; &#125; else &#123; B[k]=arr[j]; j++; &#125; &#125; for( ;j&lt;=high;j++,k++)//如果第二个子列表中仍然有元素，则追加到新列表 B[k]=arr[j]; for( ;i&lt;=mid;i++,k++)//如果在第一个子列表中仍然有元素，则追加到新列表中 B[k]=arr[i]; for(int z=0;z&lt;high-low+1;z++)//将排序的数组B的 所有元素复制到原始数组arr中 arr[z]=B[z]; &#125; 基于分治法的归并排序适用于排序大列表，代价是需要额外的内存空间。空间复杂度为O(n)，时间复杂度为O(nlogn)。比较稳定，在大列表排序情况下建议使用。 动图展示啦啦 总结这里先写5种排序方式，感谢在我学习之路上的各位大佬。秦至不知道名字哎作为一个本学期暂时没学习过数据结构和离散数学的小rookiy，我去找别人借了本大话数据看了下，发现还是直接记结论吧，因此后面的几种暂时搁置下，对这几个先熟络一下,另外展示下所有排序图片的总结 推荐这里有个好玩的东西可以推荐一下visualgo那些数据结构可在这可视化，虽然都是英文，但也有中文的，不用担太多心，科科。","categories":[],"tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://yoursite.com/tags/学习心得/"}]},{"title":"getJSON中的问题的解答，与自己的思考","slug":"2","date":"2017-05-22T11:53:06.000Z","updated":"2017-05-22T12:25:39.000Z","comments":true,"path":"2017/05/22/2/","link":"","permalink":"http://yoursite.com/2017/05/22/2/","excerpt":"返回json数据的问题在使用AFnetworking这个库做网络请求的条件下，在服务器返回json数据时，有时会出现“somevalue”:null,解析后变成somevalue=”“,为NSNull的对象，如果直接向这个对象发消息会直接崩溃，因此可以用以下的代码去掉这个讨厌的空值，将所有NSNull的值变成nil，这样就可以安心往下走了哈哈。","text":"返回json数据的问题在使用AFnetworking这个库做网络请求的条件下，在服务器返回json数据时，有时会出现“somevalue”:null,解析后变成somevalue=”“,为NSNull的对象，如果直接向这个对象发消息会直接崩溃，因此可以用以下的代码去掉这个讨厌的空值，将所有NSNull的值变成nil，这样就可以安心往下走了哈哈。 1((AFJSONResponseSerializer *)manager.responseSerializer).removesKeysWithNullValues = YES; 请求超时的问题1234//设置超时 [manager.requestSerializer willChangeValueForKey:@\"timeoutInterval\"]; manager.requestSerializer.timeoutInterval = 5;//这个值是什么意思？ //请求超时时间5s [manager.requestSerializer didChangeValueForKey:@\"timeoutInterval\"]; AFnetworking的默认请求时间好像是30s还是60s,太长了，而且好像也不太管用，对于这个getjson，不管30秒还是60都太长不需要这么久，我反正受不了，要等太久。当服务器故障，或者瞬间网络问题导致api访问有问题等等，APP会出现一直在长时间loading的情况，这个时候就需要我们来改一改了，通过以上代码设置超时，请求超时时间为5s，可以有效的返回情况，进行解决或再次访问。 懒加载1234567//为什么要有这个方法？-(NSMutableArray *)datas&#123; if (!_datas) &#123; _datas=[[NSMutableArray alloc]init]; &#125; return _datas;&#125;//懒加载，重写get方法时，先判断对象是否为空，为空在实例化对象 所谓的懒加载可以定义为：延时加载，即当对象需要用到的时候再去加载。 优点就是可以简化代码，不必将创建对象的代码全部写在viewdidload上，增强代码可读性，对系统的内存占用率会减小，而且对象的实例化在getter方法中，各司其职，降低耦合性。 没用懒加载时，需要写在viewDidLoad方法中获取，如下图所示，显而易见，当返回的msg=ok时，就直接加载当前的_datas，采用上述方法后，只会在用到时才会去加载对象，大大减小内存占用，反正就是很好就是了，实在是编不下去了。 _datas和.datas12345678if ([responseObject[@\"msg\"] isEqualToString:@\"ok\"]) &#123; //_datas=[[NSMutableArray alloc]init]; 不使用懒加载的话可以在这里用 for(NSDictionary *eachDic in responseObject[@\"links\"]) &#123; NSLog(@\"%@\",eachDic); Vedio *vedio=[[Vedio alloc]initWithDic:eachDic]; [self.datas addObject:vedio];//换成_datas会怎么样？ 懒加载调用 不初始化不会输出数据 用_datas的话不调用懒加载方法，会一直nil,对了有一点需要注意，这里用的是self.datas调用其get方法，在写懒加载时，不能用.datas判断是否为空，否则会陷入死循环。 总结以上就是关于对getjson的思考及解答，另外在这次学习中用到了afnetworking和mbprogresshud第三方库，（mbprogresshud就是转菊花进度条等等），而且又学会了用hexo和github搭建自己个人的博客，一路艰辛(鲜花掌声），慢慢的做好自己的事情，编不下去了就这样了。","categories":[{"name":"ios学习","slug":"ios学习","permalink":"http://yoursite.com/categories/ios学习/"}],"tags":[{"name":"问题思考","slug":"问题思考","permalink":"http://yoursite.com/tags/问题思考/"}]},{"title":"计算器App心得","slug":"1","date":"2017-05-22T11:42:36.000Z","updated":"2017-05-22T12:25:52.000Z","comments":true,"path":"2017/05/22/1/","link":"","permalink":"http://yoursite.com/2017/05/22/1/","excerpt":"界面搭建界面主要由清新绿色背景构成，添加三个label,四个Button,构成的一个简易的计算器，通过属性连线，编写计算","text":"界面搭建界面主要由清新绿色背景构成，添加三个label,四个Button,构成的一个简易的计算器，通过属性连线，编写计算，也没啥可说的 心得在做之前我其实是一脸懵逼的，以前写C语言的时候通常是要靠直接写，但是做出来完全没有什么好看的，其实做这个还是蛮有意思的，与C不同的是这个可以自己直接搭建界面，也不困难，虽说刚开始什么也不懂，糊里糊涂做出来，这个主要就定义了三个对象，输入num1,num2 的文本格式，在计算之前转换为duoble，然后加减乘除得出sum。做的时候也出了不少问题，不知道强弱引用，也不知道super,self是什么鬼，而且还有为什么有NS,UI等前缀，通过学习使我逐步了解，慢慢运用，最终完成这东西。 强力注释一波强弱引用：默认所有的指针变量都是强指针，强引用也就是通常所讲的引用，其存亡直接决定了所指对象的存亡。如果不存在指向一个对象的引用，并且此对象不再显示列表中，则此对象会被从内存中释放。弱引用除了不决定对象的存亡外，其他与强引用相同。即使一个对象被持有无数个若引用，只要没有强引用指向他，那么其还是会被清除。 self：在动态方法中，self代表着”对象”，在静态方法中，self代表着”类”。万变不离其宗，记住一句话就行了：self代表着当前方法的调用者。 展示","categories":[{"name":"ios学习","slug":"ios学习","permalink":"http://yoursite.com/categories/ios学习/"}],"tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://yoursite.com/tags/学习心得/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-09T13:16:32.000Z","updated":"2017-05-23T08:17:04.000Z","comments":true,"path":"2017/05/09/hello-world/","link":"","permalink":"http://yoursite.com/2017/05/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"666","slug":"666","permalink":"http://yoursite.com/tags/666/"}]}]}